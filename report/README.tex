\documentclass[11pt,a4paper]{article}

\usepackage[margin=1in]{geometry}
\usepackage{indentfirst}
\usepackage{listings}
\usepackage{color}
\usepackage{hyperref}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{orange}{rgb}{.7,.3,0}

\makeatletter
\lst@InstallKeywords k{types}{typestyle}\slshape{typestyle}{}ld
\makeatother

\lstset{
    language=Haskell,
    aboveskip=3mm,
    belowskip=3mm,
    showstringspaces=false,
    basicstyle={\small\ttfamily},
    keywordstyle=\color{blue},
    commentstyle=\color{dkgreen},
    stringstyle=\color{mauve},
    typestyle=\color{orange},
    breaklines=true,
    breakatwhitespace=true,
    moretypes={
        Map, Natural, Variable, Exponent, Coefficient, Monomial, Polynomial
    }
}

\title{PFL Project}
\author{João Pereira, Nuno Pereira}

\begin{document}

\maketitle

\pagebreak

\begin{abstract}
    TODO
\end{abstract}

\tableofcontents

\pagebreak

\section{Introduction}

The goal of this project was to implement polynomials and common operations performed on them, such as addition or derivation, using the Haskell programming language.

\section{Internal Representation}

For the internal representation of the polynomial data structure, we implemented the following:

\begin{lstlisting}
data Natural = One | Suc Natural
    deriving (Eq, Ord)

type Variable = Char

type Exponent = Natural

type Coefficient = Double

data Monomial = Monomial Coefficient (Map Variable Exponent)
    deriving (Eq)

newtype Polynomial = Polynomial [Monomial]
    deriving (Eq)
\end{lstlisting}

This allows us to represent \lstinline{Polynomial}s and \lstinline{Monomial}s in a way that naturally represents what they are, while also ensuring that the operations performed on them are efficient:

\begin{itemize}
    \item doing work on a \lstinline{Polynomial} is (almost) the same as doing the same work to each of its \lstinline{Monomial}s;

    \item working with the variables and degrees of each \lstinline{Monomial} is not only simplified but also more efficient because of the nature of the underlying \lstinline{Map} data structure.

    For example, normalizing a polynomial is done in $ \mathcal{O} \left( k' k m \times \log \left( \frac{n+1}{m+1} + k' \right) \right), m \leq n $ time instead of $ O(m k^2) $, like we had in a previous implementation:
          % these complexities are getting very strange but the comparison term is the naive "nub-like" solutions which has a worst-case complexity of O(mk²), where k is the number of monomial and m is the number of exponents
          % need to check if it actually is more efficient
          \begin{itemize}
              \item $ \mathcal{O} \left( m \times \log \left( \frac{n+1}{m+1} \right) \right), m \leq n $ for aggregating any 2 \lstinline{Monomial}s, where $n$ and $m$ are the sizes of the \lstinline{Monomial}s' "exponent map";

              \item $ \mathcal{O} (k-1) = \mathcal{O} (k) $, where $k$ is the number of \lstinline{Monomial}s in the original \lstinline{Polynomial};

              \item $ \mathcal{O} (k' \times \log(k')) $ for sorting the aggregated \lstinline{Monomial}s, where \textit{k'} is the number of \lstinline{Monomial}s in the \lstinline{Polynomial} that resulted from the previous step;
          \end{itemize}

    \item ensuring that the exponents used are \lstinline{Natural} numbers better models the mathematical definition of a \lstinline{Monomial} as well as allowing to catch unexpected bugs arising from the use of negative exponents.

\end{itemize}

\pagebreak

\section{Implementation}

\begin{itemize}
    \item \begin{lstlisting}
normalize :: Polynomial -> Polynomial
normalize (Polynomial p) = Polynomial $ sortOn Down [Monomial c exps | (exps, c) <- toList (normalizeHelper p), c /= 0]
    where
    normalizeHelper [] = empty
    normalizeHelper ((Monomial c exps) : xs) = unionWith (+) (fromList [(exps, c)]) (normalizeHelper xs)    
    \end{lstlisting}

    In the \lstinline{normalize} function we process each \lstinline{Monomial} that composes the \lstinline{Polynomial} only once, "accumulating" the desired results, which are then re-ordered, converted back into \lstinline{Monomial}s and sorted. This strategy works because, by mapping an "exponent map" to a coefficient and exploiting the \lstinline{unionWith (+)} function, we only need to calculate the union of all the \lstinline{Monomial}s: \lstinline{Monomial}s with the same "exponent map" simply have their coefficients added.

    \item \begin{lstlisting}
instance Show Polynomial where
    show (Polynomial []) = ""
    show (Polynomial [m]) = show m
    show (Polynomial (m : (Monomial c e) : ms)) = show m ++ showSign c ++ show (Polynomial (abs (Monomial c e) : ms))
        where
        showSign c = if c < 0 then " - " else " + "
    \end{lstlisting}

    In the \lstinline{show} function the \lstinline{Monomial}s are printed one at a time using the coefficient of the next \lstinline{Monomial} in the list to define the sign to show: '\lstinline{-}' if it is negative, '\lstinline{+}' otherwise.
    
    \item \begin{lstlisting}
instance Differentiable Polynomial where
    Polynomial p // v = normalize $ Polynomial $ map (// v) p
    \end{lstlisting}

    Makes a \lstinline{Polynomial} inherently differentiable. This functions basically differentiates each \lstinline{Monomial} and then normalizes the output.
\end{itemize}
    
\section{Usage examples}

\pagebreak

\appendix
\section{Appendix}

\subsection{Figures}

TODO

\end{document}
